%DATA
% vertice ids 1 to N
int: N = 4;
% vertex a
%int: a = 1;
%int: a = 2;
int: a = 2;

% vertex b
%int: b = 9;
%int: b = 8;
int: b = 3;

% edge distances matrix 
array[1..N, 1..N] of int: l = 
[|0, 2, -1, -1|
 2, 0, 10, -1|
 -1, -1, 0, 2|
 -1, -1, 2, 0|];
% VARIABLES
array[1..N, 1..N] of var 0..1 : edges; %edges[i,j] = 1 <=> ребро из i в j принадлежит кратчайшему пути из а в b
%OBJECTIVE - find shortest path from a to b
solve minimize sum(i,j in 1..N)(l[i,j]*edges[i,j]);


%CONSTRAINTS
constraint forall(i,j in 1..N where l[i,j]==-1)(edges[i,j]=0); % 1)рёбра, которых нет, точно не берём, а то они своими отрицательными длинами поломают всю логику
constraint forall(i in 1..N)(edges[i,i]=0); % 2)нет смысла стоять на месте; на длину и выбор кратчайшего пути это не повлияет, но раз можно сразу избавиться от бесполезных петель на пути, то почему бы этого не сделать

constraint sum(j in 1..N)(edges[a,j]) = 1; % 3) должны "выйти" из а; раньше тут было ">0", и вроде бы так можно и оставить, но раз уж мы по логике понимаем, что имеет смысл выйти из "а" только в одном направлении, то можно этого сразу потребовать

constraint sum(i in 1..N)(edges[i,a]) = 0; % 4) запрещаем возвращаться в "а"
constraint forall(i in 1..N)(sum(i2 in 1..N)(edges[i2,i]) <= 1); % 5) в каждую вершину приходит не больше одного взятого ребра.

constraint forall(i,j in 1..N where j!=b)(sum(j2 in 1..N)(edges[j,j2])>=edges[i,j]); % 6)если ребро взято, и его правый конец не "b", то из этого правого конца должен кто-то из взятых ребёр выходить.


%ОБЩЕЕ ОБОСНОВАНИЕ АЛГОРИТМА:
% 1) и 2) в пояснении не нуждаются. С помощью 3) заставляем алгоритм взять какое-нибудь ребро из "а". Далее 6) заставляет алгоритм продолжать этот зародыш пути новыми рёбрами, и единственный способ "утолить" 6) -- это дойти до b, либо, поскольку рёбер конечное число, устроить самопересечение (и тогда возникает цикл, как в описанном вами контрпримере к старому алгоритму). Но циклы мы запрещаем с помощью 4) и 5). 
% Действительно, если произошло самопересечение в некой вершине v, то это значит, что в неё пришли 2 ребра -- старое, которым попали в v, и новое, устроившее самопересечение. 5) отловит все такие случаи, ЗА ИСКЛЮЧЕНИЕМ v=a, т.к. тогда нет "старого ребра". Этот случай отдельно запрещает 4).

%ANSWERS case1: 42, case 2: 37, case 3: 13. 
%path itself can be seen in "edges" matrix